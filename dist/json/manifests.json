{
  "title": "Manifests",
  "modules": [
    {
      "preparagraph": "When Java-the-language added generic types in version 1.5, Java-the-virtual-machine (JVM) did not. Generic types are a fiction of the compiler. They exist at compile time, but they are omitted from the generated bytecode and are therefore unavailable at run time. This phenomenon is known as erasure. Java's type erasure leads to some peculiar limitations. To deal with these limitations, Java programmers often find themselves passing around java.lang.Class<T> objects: concrete manifestations of the otherwise abstract concept that is the type \"T\".\n\nStarting with version 2.7.2, Scala has added manifests, an undocumented (and still experimental) feature for reifying types. They take advantage of a pre-existing Scala feature: implicit parameters.\n\nTo use *Manifests*, simply add an implicit `scala.reflect.Manifest[T]` parameter to your method, like so:\n\n```\ndef name[T](implicit m: scala.reflect.Manifest[T]) = m.toString\n```\n\nThis method prints the name of any Scala type. To use it, invoke the method with some type parameter:\n\n```\nname[Int => Int] // returns \"scala.Function1[int, int]\"\n```\n\nWhen using implicit parameters, you usually have to declare a implicit identifier with the same type as your method expects, in the same scope where the method is called. With *Manifests*, the compiler automatically injects the implicit parameter for you, as long as it has enough type information to generate a *Manifest*. Essentially, this is a way of carrying over type information available at compile time into objects available at run time.",
      "code": "def inspect[T](l: List[T])(implicit manifest: scala.reflect.Manifest[T]) = manifest.toString()\nval list = 1 :: 2 :: 3 :: 4 :: 5 :: Nil\ninspect(list) should be(__)",
      "solutions": [
        "\"Int\""
      ],
      "postparagraph": ""
    },
    {
      "preparagraph": "Manifests can be attached to classes. *Manifests* have other meta-information about the type erased:",
      "code": "class Barrel[T](implicit m: scala.reflect.Manifest[T]) {\n  def +(t: T) = \"1 %s has been added\".format(m.runtimeClass.getSimpleName)\n}\nval monkeyBarrel = new Barrel[Monkey]\n(monkeyBarrel + new Monkey) should be(__)",
      "solutions": [
        "\"1 Monkey has been added\""
      ],
      "postparagraph": ""
    }
  ]
}